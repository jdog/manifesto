<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>A truly simple example</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="javascript">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="github">
<link rel="stylesheet" href="style.css">
</head>
<body>
<div class="wrapper">

<a style="font-size:24px; float:right;" href="api.html">Complete API</a>

<h1>jDog Manifesto</h1>

<div class="section">
<h4>The way people write javascript is usually messy and confusing</h4>
Over time facing badly written code takes it's toll on a developer. Engineers who find themselves writing javascript often cringe because they develop a viseral dislike of the language. Having no yearning to learn better ways of working with it, often developers resort to quick seamingly painless copy paste hacks. If you are one of those engineers, then you are looking at the problem in the wrong way. Like the English language, javascript which is the most widely used computer language runs on more devices than any other. If you are a developer writing code for websites, you need to learn how to write good javascript. 

<h4>Because so many people write ugly javascript, it is difficult to learn better ways</h4>
Javascript is a beautiful and elegant language to write. It's extremely flexible, adaptive, and modular out of the box. It's quick and easy to debug with any browser. But if you only use javascript to write (bootstrap || jQuery || Angular || Backbone || coffeescript || etc) style code then you are just stratching the surface of the beauty of the language. Vanila javascript is much easier to write then you might think. There is a ton of good and bad information out there, learn how to be selective.

<h4>That being said, as a javascript developer you do need some help in the form of basic libraries and tools.</h4>
<h5>Asynchronously waiting for js libraries to be available</h5>
jDog has been such a library for me in my trials and travails on the road of building out websites, some large, some small. It is inspired by and has the power of Require.js to load and use external javascript. But the advantage of jDog is in console based debugging, and not being limited by the AMD format. Otherwise require.js is an excellent tool to use, and if you are already using it, then stick with it. There are still things you can pick up from the 'dog pattern'.

<h5>Editing, and or creating elements in the DOM</h5>
jQuery is still the king, but if you don't mind giving up ie8 and below, you can use document.querySelector ! It's easier to debug in the console than jQuery.

<h5>Debugging</h5>
Chrome / Chromium are the best in class. jDog's PAGE variable helps bring out that power to explore the PAGE namespace. Running under a single namespace makes it easier to test, document and explore through the browser than code that is scattered or cast in anonymous functions.

<h5>There are tons of libraries out there for free, use them freely!</h5>
But try to grab the ones with the least external dependencies. Beware widgets that overwrite the jQuery variable or load a bunch of stuff you already have. Start with minimalism as the ideal. What is the least number of external stuff I need to get the project done. Then add more when there is no other way, or you don't have the time to create a custom solution. Over time you will have more understanding of your own code, and will be able to debug and fix problems easier.

<h4>Use Constructors!</h4>
Module loading scripts can build Modules and Constructors when you know how to do it. But often developers neglect Constructors as they are a bit more complex. By Modules I mean instantiated objects that exist in memory in the web browser. Constructors, at least in javascript are functions that generate Modules or properties of Modules. And it's high time they were given their fair shake. Constructors are far easier to test than Modules, because Modules are really objects, and objects are passed by reference in javascript. Functions such as Constructors functions instantiate new objects, and because of that, that can deployed and destroyed quickly to test all of the properties you come to expect. jDog makes it super easy to build when you follow the dog pattern.

<h4>Use Functions!</h4>
Functions are also amazing bits of code, and they should be treated with the same respect as Modules and Constructors.

<h4>Global Properties</h4>
Some values need to be declared at the page level where all parts of the page should have access to them.


</div>

<h3 class="mb0">Module example</h3>
Example of creating a Module, ie, immediately instantiated object

<pre id='vimCodeElement'>
<span class="Comment">//scripts/loginPage/page.modules.loginPage.js</span>

PAGE.waitAdd$(
  <span class="Constant">&quot;Modules.loginPage&quot;</span>,
  [
    <span class="Constant">&quot;Constructors.Loader&quot;</span>
    , <span class="Constant">&quot;Constructors.Login&quot;</span>
    , <span class="Constant">&quot;Modules.tracking&quot;</span>
  ]
  , <span class="Identifier">function</span>(ref) {

    <span class="Type">var</span> $form = $(<span class="Constant">&quot;#form1&quot;</span>)

    <span class="Type">var</span> dog = {
      $form : $form
      , <span class="Statement">login</span> : ref.Login( $form, { <span class="Statement">showError</span> : <span class="Constant">true</span> } )
      , <span class="Statement">loader</span> : ref.Loader().show()
    }

    dog.$form.submit(<span class="Identifier">function</span>() {
      ref.tracking.commonTrack(<span class="Constant">&quot;clicked submit&quot;</span>)
    })

    dog.login.addEvent(<span class="Constant">&quot;Success&quot;</span>, <span class="Identifier">function</span>(id, name) {
      ref.tracking.commonTrack(<span class="Constant">&quot;logged in&quot;</span>, { <span class="Statement">id</span> : id, <span class="Statement">name</span> : name })
    })

    dog.login.addEvent(<span class="Constant">&quot;Fail&quot;</span>, <span class="Identifier">function</span>(msg, err) {
      ref.tracking.commonTrack(<span class="Constant">&quot;failed login&quot;</span>, { <span class="Statement">msg</span> : msg, <span class="Statement">err</span> : err })
    })

    <span class="Statement">return</span> dog

})
</pre>

<h3 class="mb0">Constructor Example</h3>
Example of creating a Constructor, ie, code that gets instantiated by modules

<pre id='vimCodeElement'>
<span class="Comment">//scripts/page.Constructors.login.js</span>

PAGE.add(<span class="Constant">&quot;Constructors.Login&quot;</span>, <span class="Identifier">function</span>($form, options) {

  options.showError = options.showError || <span class="Constant">false</span>

  <span class="Type">var</span> dog = {
    $form : $form
    , $html : <span class="Type">undefined</span> <span class="Comment">// see below</span>
    , <span class="Statement">options</span> : options
  }
  , ref = dog.ref = { }

<span class="Comment">  // employs the PAGE events extension </span>
  PAGE.ext.events(dog, {
    <span class="Statement">Success</span> : []
    , <span class="Statement">Fail</span> : []
  })

  <span class="Identifier">function</span> build() {
    <span class="Type">var</span> html = <span class="Constant">''</span>

    html += <span class="Constant">&quot;&lt;div class='pad'&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;div class='row'&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;input type='text' name='UserName' /&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;/div&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;div class='row'&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;input type='text' name='Password' /&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;/div&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;div class='row'&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;button&gt;Submit&lt;/button&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;/div&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;/div&gt;&quot;</span>

    dog.$form.empty()
    dog.$html = $(html).appendTo(dog.$form)
  }

  <span class="Identifier">function</span> events() {

    ref.Validation(dog.$form, <span class="Identifier">function</span> success(data) {
      dog.triggerEvent(<span class="Constant">&quot;Success&quot;</span>, data.id, data.name)
    }, <span class="Identifier">function</span> fail(msg, err) {
      dog.triggerEvent(<span class="Constant">&quot;Fail&quot;</span>, msg, err)
    })

  }

  <span class="Identifier">function</span> init() {
    build()
    events()
  }

  PAGE.wait(
    <span class="Constant">&quot;Modules.dataService.read&quot;</span>
    , <span class="Constant">&quot;Constructors.Validation&quot;</span>
    , ref
    , init)

  <span class="Statement">return</span> dog

})
</pre>

<h3 class="mb0">Properties example</h3>
Example of passing values from the server side code to javascript code
<pre id='vimCodeElement'>
<span class="Identifier">&lt;</span><span class="Statement">script</span><span class="Identifier">&gt;</span>

<span class="Comment">  // boolean value</span>
<span class="Special">  PAGE.add</span>(<span class="Constant">&quot;Properties.IsTrackingOn&quot;</span><span class="Special">, @IsTrackingOn.ToString</span>(<span class="Special">).ToLower</span>(<span class="Special">))</span>

<span class="Comment">  // object with a bunch of string values</span>
<span class="Special">  PAGE.add</span>(<span class="Constant">&quot;Properties.AnnualSubscription&quot;</span><span class="Special">, </span>{
<span class="Special">    </span><span class="Statement">PlanId</span><span class="Special">: </span><span class="Constant">&quot;@annualSub.PlanId.ToString()&quot;</span>
<span class="Special">    , </span><span class="Statement">Price</span><span class="Special">: </span><span class="Constant">&quot;@annualSub.Price.ToString()&quot;</span>
<span class="Special">    , </span><span class="Statement">Description</span><span class="Special">: </span><span class="Constant">&quot;@annualSub.Description.ToString()&quot;</span><span class="Special"> </span>
<span class="Special">  })</span>

<span class="Comment">  // backend object converted directly to JSON object</span>
<span class="Special">  PAGE.add</span>(<span class="Constant">&quot;Properties.User&quot;</span><span class="Special">, @Html.Raw</span>(<span class="Special">Json.Encode</span>(<span class="Special">ViewBag.CurrentMember)))</span>

<span class="Identifier">&lt;/</span><span class="Statement">script</span><span class="Identifier">&gt;</span>
</pre>

<h3 class="mb0">Comment heavy Constructor example</h3>
<pre id='vimCodeElement'>
<span class="Comment">// First Parameter is the name with namespace</span>
<span class="Comment">// in this example, a Constructor that takes two parameters</span>
<span class="Comment">//</span>
<span class="Comment">// Constructors are a special kind of function</span>
<span class="Comment">// that creates an object that has public methods and properties</span>
<span class="Comment">// this simple example has three public properties</span>
<span class="Comment">// $form, $html, and options</span>
<span class="Comment">//</span>
<span class="Comment">// it also has a public (Module) property, validation</span>
<span class="Comment">//</span>
<span class="Comment">// in addition, because it employs the events extension</span>
<span class="Comment">// the following methods are added as well</span>
<span class="Comment">//</span>
<span class="Comment">// addEvent( String, Function )</span>
<span class="Comment">// triggerEvent ( String, property, property ... )</span>
<span class="Comment">//</span>
<span class="Comment">// as well as this events object</span>
<span class="Comment">// events {</span>
<span class="Comment">//  Success : Array</span>
<span class="Comment">//  , Fail : Array</span>
<span class="Comment">//  , SubmitClick : Array</span>
<span class="Comment">// }</span>

PAGE.add(<span class="Constant">&quot;Constructors.Login&quot;</span>, <span class="Identifier">function</span>($form, options) {

<span class="Comment">  // define options if not defined</span>
  options = options || { }

<span class="Comment">  // options are optional, this line of code falls back to false if property is not defined</span>
  options.showError = options.showError || <span class="Constant">false</span>

<span class="Comment">  // ah, the beloved dog</span>
<span class="Comment">  // a dog is the equivalent to the exports object</span>
<span class="Comment">  // the dog is the thing that gets returned from the contructor</span>
<span class="Comment">  // the dog is defined in this way to create a legend towards</span>
<span class="Comment">  // the top of the file, to allow for quick reference</span>

  <span class="Type">var</span> dog = {
    $form : $form
    , $html : <span class="Type">undefined</span> <span class="Comment">// see below</span>
    , <span class="Statement">options</span> : options
    , <span class="Statement">validation</span> : <span class="Type">undefined</span> <span class="Comment">// see below</span>
  }

<span class="Comment">  // the reference object, AKA ref is an object to house all external libraries</span>
  , ref = dog.ref = { }

<span class="Comment">  // employs the PAGE events extension </span>
<span class="Comment">  // this adds publically available events based on these names</span>
<span class="Comment">  // these events are a series of functions that get fired when the named event is triggered</span>
  PAGE.ext.events(dog, {
    <span class="Statement">Success</span> : []
    , <span class="Statement">Fail</span> : []
    , <span class="Statement">SubmitClick</span> : []
  })

<span class="Comment">  // a very common technique is to generate all of the HTML needed in this file</span>
<span class="Comment">  // having html defined outside of the constructor is also valid, but may lead to greater complexity</span>
<span class="Comment">  // when it comes to file management</span>
  <span class="Identifier">function</span> build() {
<span class="Comment">    // create some html the tried and true way</span>
    <span class="Type">var</span> html = <span class="Constant">''</span>

    html += <span class="Constant">&quot;&lt;div class='pad'&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;div class='row'&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;input type='text' name='UserName' /&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;/div&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;div class='row'&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;input type='text' name='Password' /&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;/div&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;div class='row'&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;button&gt;Submit&lt;/button&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;/div&gt;&quot;</span>
    html += <span class="Constant">&quot;&lt;/div&gt;&quot;</span>

<span class="Comment">    // empty out the container to place it just in case</span>
    dog.$form.empty()
<span class="Comment">    // and then populate the container with newly formed jQuery code</span>
    dog.$html = $(html).appendTo(dog.$form)
  }

<span class="Comment">  // also extremely common practice is to create an events function</span>
<span class="Comment">  // this is a great place to trigger any named events, add click events through jQuery etc</span>
<span class="Comment">  // events should be fired after the HTML has been built</span>
<span class="Comment">  // events should relate directly to the built HTML and not the global HTML on the page</span>
<span class="Comment">  // this greatly increases the speed of building out the HTML</span>
  <span class="Identifier">function</span> events() {

<span class="Comment">    // here is an example of calling a library constructor</span>
<span class="Comment">    // notice that the dog.validation object get built by the Validation Constructor</span>
<span class="Comment">    // also notice that this validation constructor has two function callbacks, success and fail</span>
    dog.validation = ref.Validation(dog.$form, <span class="Identifier">function</span> success(data) {

<span class="Comment">      // this triggers the Success event upon the success callback firing</span>
<span class="Comment">      // notice that it is passing in data from the data object</span>
      dog.triggerEvent(<span class="Constant">&quot;Success&quot;</span>, data.id, data.name)

    }, <span class="Identifier">function</span> fail(msg, err) {

<span class="Comment">      // this triggers the Fail event upon the fail callback firing</span>
<span class="Comment">      // notice that it is passing in msg, and err</span>
      dog.triggerEvent(<span class="Constant">&quot;Fail&quot;</span>, msg, err)
    })

<span class="Comment">    // the following code starts the validation code to run</span>
<span class="Comment">    // this specific code keeps checking until the code is valid showing errors as you type</span>
    dog.$form.click(<span class="Identifier">function</span>() {

<span class="Comment">      // this triggers the SubmitClick event</span>
<span class="Comment">      // notice that it is passing in dog.$form</span>
      dog.triggerEvent(<span class="Constant">&quot;SubmitClick&quot;</span>, dog.$form)

<span class="Comment">      // line that starts the validation, a public method of the validation Module embedded in this constructor</span>
      dog.validation.startValidation()
    })

  }

<span class="Comment">  // init is the code that starts everything running</span>
<span class="Comment">  // in this example, init only fires after all external libraries are loaded</span>
  <span class="Identifier">function</span> init() {
    build()
    events()
  }

  PAGE.wait(
    <span class="Constant">&quot;Modules.dataService.read&quot;</span> <span class="Comment">// example not shown here</span>
    , <span class="Constant">&quot;Constructors.Validation&quot;</span> <span class="Comment">// see above for usage</span>
    , ref <span class="Comment">// passing in the reference object here</span>
    , init) <span class="Comment">// finally firing this function when it's done loading</span>

<span class="Comment">  // finally return the dog</span>
<span class="Comment">  // consider dog like the exports object, or the this object</span>
  <span class="Statement">return</span> dog

})
</pre>

<h3 class="mb0">Augmented Module pattern</h3>
<pre id='vimCodeElement'>
<span class="Comment">// Module augmentation pattern</span>

PAGE.wait(
  <span class="Constant">&quot;Modules.basePage&quot;</span>
  , <span class="Constant">&quot;Properties.User&quot;</span>
  , <span class="Constant">&quot;Modules.dataService.write&quot;</span>
  , {}
  , <span class="Identifier">function</span>(ref) {

<span class="Comment">    // extends the functionality of basePage</span>

    ref.basePage.User = ref.User

    ref.basePage.finish(<span class="Identifier">function</span>() {
      ref.write.saveState(<span class="Constant">123</span>, <span class="Constant">&quot;abc&quot;</span>)
    })

  })

</pre>

<h3 class="mb0">Waiting for external libraries</h3>
<pre id='vimCodeElement'>
<span class="Comment">// waiting for external javascript</span>

PAGE.wait(
  <span class="Constant">&quot;window.jQuery.fn.select2&quot;</span>
  , <span class="Constant">&quot;Modules.dataService.read&quot;</span>
  , {}
  , <span class="Identifier">function</span>(ref) {

    ref.read.getStates(<span class="Identifier">function</span>(states) {
      $(<span class="Constant">&quot;#select2&quot;</span>).select2()
    })

  })

</pre>

<h4>History &amp; philosophy</h4>
<div class="jump">
<a href="#intro">organizing code</a>
<a href="#intro">the single PAGE variable</a>
<a href="#earlyExample">early attempts</a>
<a href="#loadingProblem">the asynchronous loading problem</a>
</div>

<h4>Usage and Structure</h4>
<div class="jump">
<a href="#existential">PAGE is existential</a>
<a href="#order">loading order</a>
<a href="#structure">Structure</a>
<a href="#modules">Modules</a>
<a href="#constructors">Constructors</a>
<a href="#properties">Properties</a>
<a href="#functions">Functions</a>
<a href="#thirdParty">3rd party Libraries</a>
<a href="#jQuery2">jQuery</a>
<a href="#extensions">Extensions</a>
<a href="#custom">Custom</a>
</div>

<h4><a href="api.html">Complete API</a></h4>

<div id="organize" class="section">
<h2>Organizing code</h2>
There are many ways of organizing code to a website. From the early days of the web, with pure html, images, and maybe a few CGI scripts things were relatively easy. A few key folders, some files, and a few server settings. It's very easy to organize something that is simple which does very little. Things get more complicated as you introduce more functionality. As I write this in late 2014, javascript has become a driving force in the way developers think about and organize their web projects. There are many reasons for this trend, mostly boiling down to demand from consumers and product development requirements.
</div>

<div class="section" id="intro">
<h2>Why have a <i class="c">PAGE</i> variable</h2>
The <i class="c">PAGE</i> variable started out in the frustration of inheriting code from many different projects. When inheriting a project for the first time, certain important variables would be hidden inside the global window object, such as CurrentMemberId, or CampaignClass etc for example. Often javascript files would have functions and variables all meshed together, calling and modifying each other. 

For small projects this practice is understandable, but as the web evolved to expect ajax style interaction this practice broke down. This is especially true when trying to modify older code writing in this way. If you didn't know what to look for or have easy access to the complete code base, you can spend a lot of time just digging through the code to find what you need. Time wasted.

Viewing source (back in the day) would produce some serious speghetti. It took a long time to understand the scope of adding new features. And often, features would never get removed since doing so could break something somewhere else in unexpected ways. In short it was a mess, and there was no standard way of organizing all of the mess.

For these reasons and many others I made the decision that for any new projects I would store things into a common variable called <i class="c">PAGE</i>. In that way, if I hadn't worked on the project in awhile I could type <i class="c">PAGE</i> in the console to peak at what was happening and get up to speed quickly.

<h3 id="earlyExample">At first the code looked something like this:</h3>

<pre>
  <span class="Statement">if</span> (<span class="Statement">typeof</span> PAGE === <span class="Constant">&quot;undefined&quot;</span>) {
    PAGE = { }
  }
  PAGE.SomeProperty = <span class="Constant">12314</span>

</pre>

But this technique got annoying, since you always had to check for null. And if you had nested properties, it got even worse.

<pre>
  <span class="Statement">if</span> (<span class="Statement">typeof</span> PAGE !== <span class="Constant">&quot;undefined&quot;</span>) {

    <span class="Statement">if</span> (PAGE.someThing &amp;&amp; PAGE.someThing.someProperty) {
<span class="Comment">      // ... do something</span>
    } <span class="Statement">else</span> {
<span class="Comment">      // ... looks like it's not defined</span>
    }

  }
</pre>

This constant need for retrieving and adding nested properties (PAGE.Something.SomethingElse) prompted me to come up with a standard way of accessing nested properties inside the <i class="c">PAGE</i> variable or window object.

This required PAGE to be it's own library, and to be loaded first. But it solved all problems of asynchronous loading. After a couple rewrites, I eventually came up with this type of syntax:

<h3 class="mb0">Checking if a path exists</h3>
<pre>
<span class="Comment">// if Part1 of SomeOtherThing of Something of PAGE exists return it</span>
PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>)

<span class="Comment">// if Part1 of SomeOtherThing of Something of window exists return it</span>
PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>, window)

<span class="Comment">// if Part1 of SomeOtherThing of Something of window exists return it, otherwise 123</span>
PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>, window, <span class="Constant">123</span>)
</pre>

<div class="expand">Source code for checking Existence</div>
<div class="expanse">

As you can see the essense of exists is pretty simple. First, split out the path by periods. The inner <i class="c">obj</i> variable gets redefined on each pass through the while loop. If it reaches an undefined or null it stops prematurely, otherwise it returns the property requested. Finally, there is an alternative variable which will return optionally if either the thing is undefined or the value is null.

<pre>
<span class="Type">var</span> exists = <span class="Identifier">function</span> (path, base, alternate) {
  <span class="Statement">if</span> (<span class="Statement">typeof</span> path === <span class="Constant">&quot;undefined&quot;</span> || <span class="Statement">typeof</span> path === <span class="Constant">&quot;object&quot;</span>) <span class="Statement">return</span>
  <span class="Type">var</span> arr = path.split(<span class="Constant">&quot;.&quot;</span>)
    , x = <span class="Constant">0</span>
    , obj = base || PAGE

  <span class="Statement">if</span> (arr.length &lt; <span class="Constant">1</span>) <span class="Statement">return</span> alternate

  <span class="Statement">while</span> (x &lt; arr.length) {
    obj = obj[arr[x]]
    <span class="Statement">if</span> (obj === <span class="Type">undefined</span> || obj === <span class="Type">null</span>) <span class="Statement">return</span> alternate
    x++
  }
  <span class="Statement">if</span> (<span class="Statement">typeof</span> obj !== <span class="Constant">&quot;undefined&quot;</span>)
    <span class="Statement">return</span> obj
  <span class="Statement">else</span>
    <span class="Statement">return</span> alternate
}


</pre>

</div>

<h3 class="mb0">Interesting tricks of existential awareness!</h3>
<pre id='vimCodeElement'>
<span class="Comment">// here are some cool things you can do with exists</span>

<span class="Comment">// somewhere in my project I have defined a function</span>

MyProject.someAmazingModule.reload = <span class="Identifier">function</span>(delay) { <span class="Comment">/* ......... */</span> }

<span class="Comment">// and I am not entirely sure it has loaded yet, but I don't want to wait for it</span>

PAGE.exists(<span class="Constant">&quot;someAmazingModule.reload&quot;</span>, MyProject, <span class="Identifier">function</span>(){})( <span class="Constant">500</span> )

<span class="Comment">// what did that just do?</span>
<span class="Comment">//</span>
<span class="Comment">// 1. Look inside window.MyProject for someAmazingModule</span>
<span class="Comment">// 2. look inside someAmazingModule for reload</span>
<span class="Comment">// 3. return it and call it with 500 as the parameter</span>
<span class="Comment">// 4. if it's not there, return and call anonymous function</span>
</pre>

<h3 id="loadingProblem">The asynchronous loading problem</h3>
A good practice to employ while coding is seperating concerns. In javaScript this is done by saving different functions or objects as their own files, usually with a unique name for the file that corresponds to the unique name of the function or object. As a project grows in complexity, remembering all of these names becomes a real problem. If only there was a way to group these objects and functions into a <i class="c">Namespace</i>.

Compiled language namespace solutions use a <i class="c">Using</i> statement towards the top of the file. Upon compilation, the required libraries are then hoisted into scope to be access by the code that needs them. In javascript it is not that simple because everything is loading asynchronously. 

A working solution, though a bad one, would wait for all required libraries to be loaded, and then to run the code. Talk about two steps forward, three steps back. Could you imagine a website today waiting for the page to load all of the images before displaying a single line of text? 

A better solution would split the work of a <i>Component</i> into the parts that can run without external <i>Components</i> and the parts that require external components. In this way the processor would work on the stuff that it can now, then get to the stuff that is still being loaded later. Thanks to the power of javascript you can do this very thing, as the scope in the closure allows full access to variables long after they are first loaded.

And this is the essense of what has now become known as jdog.

</div>

<div class="section" id="order">
<h2>The Order of things</h2>

When working with asynchronous code, you never can be absolutely sure of the load order. For PAGE (jdog) to work properly, it should be added before any other PAGE items. Also, though it's not dependant on jQuery, it certainly interacts with jQuery faster if jQuery is loaded before PAGE. Normally I load jQuery through google's hosted library. This speeds up the page loading since the source is coming from a different domain.

<h3>Ideal Order</h3>
<pre>
	1) PAGE.loader.js          // add this to the PAGE bundle, or directly on HTML
	2) PAGE.base.js            // add this to the PAGE bundle
	3) jQuery                  // add this to the page bundle
	4) (any page extensions)   // add this to the PAGE bundle
	5) (any page constructors or functions or properties)
	6) (any page modules)
</pre>

</div>

<div class="section" id="structure">
<h2>Structure of your PAGE</h2>

To a large degree the structure of your page is up to you. <i>jdog</i> is not a framework like angular or similar libraries that requires a rigid structure or pattern to develop around. jdog is framework independant. This means you have more freedom to adapt other javascript libraries since there are no dependency conflicts to contend with. It really is up to you to structure your code the best way you can. jdog is a library management tool.

Javascript is a very expressive language which allows for many different types of patterns. In my practice the following ways of grouping code have been beneficial.

<dl>
<dt>Modules</dt>
<dd>These are the instantiated objects in the page</dd>
<dt>Constructors</dt>
<dd>These are functions that Construct Objects (either Modules, or the sub parts to Modules)</dd>
<dt>Functions</dt>
<dd>Stateless scripts that affect Modules or their parts</dd>
<dt>Properties</dt>
<dd>Global variables which allow easy communication from backend</dd>
<dt>Extensions</dt>
<dd>Scripts which extend the functionality of the PAGE library</dd>
<dt>Module Extenders</dt>
<dd>Bits of code that expand the functionality of modules</dd>
<dt>External Libraries</dt>
<dd>Any of a million javascript libraries</dd>
</dl>


</div>

<div class="section" id="modules">
<h2>What do I mean by Module?</h2>
A Module is an Object that exists on your page with public properties and methods. Modules are stateful Singletons. Whereas a Function takes parameters and runs some script, Modules are the thing itself. They rarely if ever get removed, instead their properties change states. This is the home for active code running on the page, and should be the first place to look in order to understand the structure of what is happening. So for example if you are working on the home page of a site, then you can assume that PAGE.Modules.home will be there. Always start with PAGE in console, and just explore the Modules object first.
</div>

<div class="section" id="constructors">
<h2>Constructors</h2>
Constructors are functions that create Objects. They are Stateless, in that they themselves remain constant, generating Objects based on the parameters being passed in. All things considered, while Modules are required, Constructors are not. But the benefit of building out functionality as a Constructors instead of just as a part of a Module is that Constructors are easier to test. Because they are stateless, you can generate many objects from them, testing different combinations, and disposing of the objects when you are done. The same cannot be said for Modules.
</div>

<div class="section" id="functions">
<h2>Functions</h2>
Functions are stateless bits of code that do something for you without needing to generate objects. They might be used to modify objects, or numbers, or strings, or any other kind of quick work. Functions are the easiest thing to test, since there is an input and an output.
</div>

<div class="section" id="properties">
<h2>Properties</h2>
Properties are a repository for holding all of the global variables for a site. I generally put things like the User object. Since they are global, any Function, Constructor, or Module can read from them, or even write to them. They have no methods to themselves. They are mute that way.
</div>

<div class="section" id="thirdParty">
<h2>Third Party Libraries</h2>
Third Party libraries can be adapted into PAGE. jdog is pure javascript, but works best with jQuery. It can be modified for other DOM type libraries, but shouldn't have to. Third Party Libraries can be added in different ways, or waited for in different ways. Generally, external libraries add to the Global window object.

To load the script from PAGE, you would use PAGE.addExternalLib
if you have the script bundled, and you only want to reference it, then you can get to it either with:

PAGE.waitWindow
PAGE.batchWaitWindow

The benefit of batchWaitWindow is you can pass in many external library namespaces, and if you include a true flag, then the library will be added into PAGE.Lib. Later on you can simply call PAGE.wait("Lib.SomeLib", "Lib.SomeOtherLib", ref, function(...)

</div>

<div class="section" id="jQuery2">
<h2>jQuery is a special little library</h2>
I don't claim to love many javascript libraries, but I do love jQuery. It's a special case, so much so in fact that PAGE has it built in. Normally for jQuery you would need the following to ensure that jQuery is ready.

<pre>
$(document).ready(<span class="Identifier">function</span>() {

<span class="Comment">  // lets do some good</span>

})
</pre>

But I love jQuery and really don't want to have to type this:

<pre>
$(document).ready(<span class="Identifier">function</span>() {


  PAGE.add(<span class="Constant">&quot;Modules.demo&quot;</span>, (<span class="Identifier">function</span>() {

<span class="Comment">    // lets do some good</span>

  }()))

})
</pre>

So I created, out of necessity, the following:

<pre>
PAGE.add$("Modules.demo", (function() {

	// lets do some good

}()))
</pre>

The above code will first wait until jQuery is 'ready', ie, jQuery is loaded, and the DOM is ready, then it will add your module. Ideally you would only need this for Modules, since only modules interact directly with the DOM. Constructors and Functions only get instantiated after Modules, therefore it is fair to assume that jQuery is loaded.

</div>

<div class="section" id="extensions">
<h2>Extensions</h2>
Extensions are scripts that extend the PAGE library itself. Here is an example of one:

<pre>
PAGE.extend(<span class="Identifier">function</span>(puppy, dog, log) {

  dog.GetTime = <span class="Identifier">function</span>() {
<span class="Comment">    // your code</span>
  }

})
</pre>

As for convention, puppy is the instance, dog is the prototype, and log is any logging to console. It's easy to remember, that's why it's like that. If you must know, instance properties for PAGE act the same as prototype properties to PAGE. What's nice is to keep them seperated. In this way, prototype methods and properties can be hidden, and the output of typing PAGE is much cleaner.

</div>

<div class="section" id="custom">
<h2>Custom</h2>
It's perfectly common for javascript to have all sorts of interesting patterns. Javascript is one of the most expressive languages, and as such people try different ways of writing it.

Here is some interesting code to ponder:

<pre>
<span class="Comment">// setup a base component</span>
PAGE.add(<span class="Constant">&quot;Components.Base&quot;</span>, <span class="Identifier">function</span>(obj) {

<span class="Comment">  // this utilizes what is called the module pattern</span>
<span class="Comment">  // an object is brought in and extended</span>

  obj.someProperty  = obj.someProperty  || <span class="Constant">123</span>
  obj.someProperty2 = obj.someProperty2 || { <span class="Statement">blah</span> : <span class="Constant">true</span> }

  obj.doSomething = <span class="Identifier">function</span>() {
<span class="Comment">    // your code</span>
  }

  <span class="Statement">return</span> obj

})

<span class="Comment">// create a component based on the Base component</span>
PAGE.add(<span class="Constant">&quot;Components.Input&quot;</span>, <span class="Identifier">function</span>(<span class="Comment">/* lots of stuff here */</span>) {

<span class="Comment">  // with this pattern we must ensure the Components.Base is fully loaded</span>
  <span class="Type">var</span> base = PAGE.exists(<span class="Constant">&quot;Components.Base&quot;</span>) || <span class="Identifier">function</span>(obj){ <span class="Statement">return</span> obj }

  <span class="Type">var</span> dog = base({

    <span class="Statement">someProperty</span> : <span class="Constant">514</span>
    , <span class="Statement">DoThis</span> : <span class="Identifier">function</span>() {
<span class="Comment">      // blah blah</span>
    }

  })

  <span class="Statement">return</span> dog

})

</pre>


</div>

</div>
</body>
</html>
