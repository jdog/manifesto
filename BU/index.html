<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>A truly simple example</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="javascript">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="github">
<link rel="stylesheet" href="style.css">
</head>
<body>

<div class="wrapper">
<h1>jdog Framework</h1>

<h4>History &amp; philosophy</h4>
<div class="jump">
<a href="#intro">Organizing Code</a>
<a href="#intro">A single PAGE variable</a>
<a href="#earlyExample">early examples</a>
<a href="#loadingProblem">dealing with the asynchronous loading problem</a>
<a href="#jdog">jdog framework to the rescue</a>
</div>

<h4>Usage and Structure</h4>
<div class="jump">
<a href="#existential">PAGE is existential</a>
<a href="#order">loading order</a>
<a href="#structure">Structure</a>
<a href="#modules">Modules</a>
<a href="#constructors">Constructors</a>
<a href="#properties">Properties</a>
<a href="#functions">Functions</a>
<a href="#thirdParty">3rd party Libraries</a>
<a href="#jQuery2">jQuery</a>
<a href="#extensions">Extensions</a>
<a href="#custom">Custom</a>
</div>

<h4>Complete API</h4>
<div class="jump">
<a href="#">PAGE is existential</a>
<a href="#AddExternalLib">AddExternalLib</a>
<a href="#SwapLib">SwapLib</a>
<a href="#add">add</a>
<a href="#add$">add$</a>
<a href="#addExternalLib">addExternalLib</a>
<a href="#batchWait">batchWait</a>
<a href="#batchWaitRef">batchWaitRef</a>
<a href="#batchWaitWindow">batchWaitWindow</a>
<a href="#done">done</a>
<a href="#extend">extend</a>
<a href="#getType">getType</a>
<a href="#loadScript">loadScript</a>
<a href="#loadStyle">loadStyle</a>
<a href="#log">log</a>
<a href="#mapArguments">mapArguments</a>
<a href="#remove">remove</a>
<a href="#spawn">spawn</a>
<a href="#stash">stash</a>
<a href="#version">version</a>
<a href="#waitExists">waitExists</a>
<a href="#waitList">waitList</a>
</div>

<div id="organize" class="section">
<h2>Organizing code</h2>

There are many ways of organizing code to a website. From the early days of the web, with pure html, images, and maybe a few CGI scripts things were relatively easy. A few key folders, some files, and a few server settings. It's very easy to organize something that is simple which does very little. Things get more complicated as you introduce more functionality. As I write this in late 2014, javascript has become a driving force in the way developers think about and organize their web projects. There are many reasons for this trend, mostly boiling down to demand from consumers and product development requirements.



</div>


<div class="section" id="intro">
<h2>Why have a <i class="c">PAGE</i> variable</h2>

The <i class="c">PAGE</i> variable started out in the frustration of inheriting code from many different projects. When inheriting a project for the first time, certain important variables would be hidden inside the global window object, such as CurrentMemberId, or CampaignClass etc for example. Often javascript files would have functions and variables all meshed together, calling and modifying each other. 

For small projects this practice is understandable, but as the web evolved to expect ajax style interaction this practice broke down. This is especially true when trying to modify older code writing in this way. If you didn't know what to look for or have easy access to the complete code base, you can spend a lot of time just digging through the code to find what you need. Time wasted.

Viewing source (back in the day) would produce some serious speghetti. It took a long time to understand the scope of adding new features. And often, features would never get removed since doing so could break something somewhere else in unexpected ways. In short it was a mess, and there was no standard way of organizing all of the mess.

For these reasons and many others I made the decision that for any new projects I would store things into a common variable called <i class="c">PAGE</i>. In that way, if I hadn't worked on the project in awhile I could type <i class="c">PAGE</i> in the console to peak at what was happening and get up to speed quickly.

<h3 id="earlyExample">At first the code looked something like this:</h3>

<code>
  <span class="Statement">if</span> (<span class="Statement">typeof</span> PAGE === <span class="Constant">&quot;undefined&quot;</span>) {
    PAGE = { }
  }
  PAGE.SomeProperty = <span class="Constant">12314</span>

</code>

But this technique got annoying, since you always had to check for null. And if you had nested properties, it got even worse.

<code>
  <span class="Statement">if</span> (<span class="Statement">typeof</span> PAGE !== <span class="Constant">&quot;undefined&quot;</span>) {

    <span class="Statement">if</span> (PAGE.someThing &amp;&amp; PAGE.someThing.someProperty) {
<span class="Comment">      // ... do something</span>
    } <span class="Statement">else</span> {
<span class="Comment">      // ... looks like it's not defined</span>
    }

  }
</code>

This constant need for retrieving and adding nested properties (PAGE.Something.SomethingElse) prompted me to come up with a standard way of accessing nested properties inside the <i class="c">PAGE</i> variable or window object.

After a couple rewrites, I eventually came up with this type of syntax:

<code>
<span class="Comment">// if Part1 of SomeOtherThing of Something of PAGE exists return it</span>
PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>)

<span class="Comment">// if Part1 of SomeOtherThing of Something of window exists return it</span>
PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>, window)

<span class="Comment">// if Part1 of SomeOtherThing of Something of window exists return it, otherwise 123</span>
PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>, window, <span class="Constant">123</span>)
</code>

This required PAGE to be it's own library, and to be loaded first. But it solved all problems of asynchronous loading.

<div class="expand">Source code for checking Existence</div>
<div class="expanse">

As you can see the essense of exists is pretty simple. First, split out the path by periods. The inner <i class="c">obj</i> variable gets redefined on each pass through the while loop. If it reaches an undefined or null it stops prematurely, otherwise it returns the property requested. Finally, there is an alternative variable which will return optionally if either the thing is undefined or the value is null.

<code>
<span class="Type">var</span> exists = <span class="Identifier">function</span> (path, base, alternate) {
  <span class="Statement">if</span> (<span class="Statement">typeof</span> path === <span class="Constant">&quot;undefined&quot;</span> || <span class="Statement">typeof</span> path === <span class="Constant">&quot;object&quot;</span>) <span class="Statement">return</span>
  <span class="Type">var</span> arr = path.split(<span class="Constant">&quot;.&quot;</span>)
    , x = <span class="Constant">0</span>
    , obj = base || PAGE

  <span class="Statement">if</span> (arr.length &lt; <span class="Constant">1</span>) <span class="Statement">return</span> alternate

  <span class="Statement">while</span> (x &lt; arr.length) {
    obj = obj[arr[x]]
    <span class="Statement">if</span> (obj === <span class="Type">undefined</span> || obj === <span class="Type">null</span>) <span class="Statement">return</span> alternate
    x++
  }
  <span class="Statement">if</span> (<span class="Statement">typeof</span> obj !== <span class="Constant">&quot;undefined&quot;</span>)
    <span class="Statement">return</span> obj
  <span class="Statement">else</span>
    <span class="Statement">return</span> alternate
}


</code>

</div>

<h3 id="loadingProblem">The asynchronous loading problem</h3>
A good practice to employ while coding is seperating concerns. In javaScript this is done by saving different functions or objects as their own files, usually with a unique name for the file that corresponds to the unique name of the function or object. As a project grows in complexity, remembering all of these names becomes a real problem. If only there was a way to group these objects and functions into a <i class="c">Namespace</i>.

Compiled language namespace solutions use a <i class="c">Using</i> statement towards the top of the file. Upon compilation, the required libraries are then hoisted into scope to be access by the code that needs them. In javascript it is not that simple because everything is loading asynchronously. 

A working solution, though a bad one, would wait for all required libraries to be loaded, and then to run the code. Talk about two steps forward, three steps back. Could you imagine a website today waiting for the page to load all of the images before displaying a single line of text? 

A better solution would split the work of a <i>Component</i> into the parts that can run without external <i>Components</i> and the parts that require external components. In this way the processor would work on the stuff that it can now, then get to the stuff that is still being loaded later. Thanks to the power of javascript you can do this very thing, as the scope in the closure allows full access to variables long after they are first loaded.

And this is the essense of what has now become known as jdog.
	
<div class="section" id="jdog">
<h2>PAGE is jdog, jdog is PAGE</h2>
jdog is the library for managing large unruly javascript projects. 
</div>


<h3>waiting until something is there</h3>
<code>
<span class="Comment">// Works for one library item</span>
PAGE.wait(<span class="Constant">&quot;Constructors.SomeConstructor&quot;</span>, <span class="Identifier">function</span>(SomeConstructor) {

  <span class="Type">var</span> someConstructor = SomeConstructor()

})

<span class="Comment">// Works for one or more library item</span>
PAGE.wait(<span class="Constant">&quot;Constructors.SomeConstructor&quot;</span>, <span class="Constant">&quot;Modules.someModule&quot;</span>, {}, <span class="Identifier">function</span>(ref) {

  ...
  <span class="Type">var</span> someConstructor = ref.SomeConstructor(ref.someModule)

})
</code>

<h3>Adding to the <i class="c">PAGE</i></h3>
<code>
PAGE.add(<span class="Constant">&quot;Constructors.MyConstructor&quot;</span>, <span class="Identifier">function</span>() {
<span class="Comment">  // your code</span>
})

PAGE.add(<span class="Constant">&quot;Modules.dataService&quot;</span>, (<span class="Identifier">function</span>() {
<span class="Comment">  // your code</span>
}()))
</code>


<h3>Waiting for a library item and then adding to the library</h3>
<code>
PAGE.wait(<span class="Constant">&quot;Constructors.SomeConstructor&quot;</span>, <span class="Identifier">function</span>(SomeConstructor) {

  <span class="Type">var</span> prefs = {
    <span class="Statement">blah</span> : <span class="Constant">true</span>
    , <span class="Statement">blahBlah</span> : <span class="Constant">false</span>
    , <span class="Statement">kind</span> : <span class="Constant">&quot;abc&quot;</span>
  }

  PAGE.add(<span class="Constant">&quot;Modules.someModule&quot;</span>, SomeConstructor(prefs))

})
</code>

<h3>Waiting for many things and then adding to the library</h3>
<code>
PAGE.wait(<span class="Constant">&quot;Constructors.SomeConstructor&quot;</span>, <span class="Constant">&quot;Modules.dataService&quot;</span>, <span class="Constant">&quot;Modules.dataService.read&quot;</span>, {}, <span class="Identifier">function</span>(ref) {

  <span class="Type">var</span> prefs = {
    <span class="Statement">blah</span> : <span class="Constant">true</span>
    , <span class="Statement">blahBlah</span> : <span class="Constant">false</span>
    , <span class="Statement">kind</span> : <span class="Constant">&quot;abc&quot;</span>
  }

  PAGE.add(<span class="Constant">&quot;Modules.someModule&quot;</span>, ref.SomeConstructor(prefs, ref.dataService))

})
</code>

With this combination of wait and add, extremely complex relationships of dependancy can be explicitly codified in a readable way. This aids in creating testable code as well since external library dependancies are now defined and therefore can be specifically mocked while testing the code.

With many library items already created (including a robust testing framework, localStorage management, Modals, browser detection) the code base has grown in breadth and depth. Each new project adds a bit more to the total library of reusable components.

</div>

<div class="section" id="order">
<h2>The Order of things</h2>

When working with asynchronous code, you never can be absolutely sure of the load order. For PAGE (jdog) to work properly, it should be added before any other PAGE items. Also, though it's not dependant on jQuery, it certainly interacts with jQuery faster if jQuery is loaded before PAGE. Normally I load jQuery through google's hosted library. This speeds up the page loading since the source is coming from a different domain.

<h3>Ideal Order</h3>
<code>
	1) jQuery
	2) PAGE.js                 // add this to the PAGE bundle
	3) (any page extensions)   // add this to the PAGE bundle
	4) (any page constructors or functions or properties)
	5) (any page modules)
</code>

</div>

<div class="section" id="structure">
<h2>Structure of your PAGE</h2>

To a large degree the structure of your page is up to you. <i>jdog</i> is not a framework like angular or similar libraries that requires a rigid structure or pattern to develop around. jdog is framework independant. This means you have more freedom to adapt other javascript libraries since there are no dependency conflicts to contend with. It really is up to you to structure your code the best way you can. jdog is a library management tool.

That being said, there are certain fundamental structures to enhance and ease the creation of your code.

<h4>When dealing with the structure of a PAGE, I have followed the following pattern. </h4>
<dl>
<dt>Modules</dt>             
<dd>These are the instantiated objects in the page</dd>
<dt>Constructors</dt>        
<dd>These are functions that Construct Objects (either Modules, or the sub parts to Modules)</dd>
<dt>Functions</dt>           
<dd>Stateless scripts that affect Modules or their parts</dd>
<dt>Properties</dt>          
<dd>Global PAGE variables which allow easy communication from backend</dd>
<dt>Extensions</dt>          
<dd>Scripts which extend the functionality of the PAGE library</dd>
<dt>Custom Constructors</dt> 
<dd>These are project dependant Constructors (think Base Classes here)</dd>
<dt>External Libraries</dt>  
<dd>Any of a million javascript libraries</dd>
</dl>


</div>

<div class="section" id="modules">
<h2>What do I mean by Module?</h2>
A Module is an Object that exists on your page with public properties and methods. Modules are stateful Singletons. Whereas a Function takes parameters and runs some script, Modules are the thing itself. They rarely if ever get removed, instead their properties change states. This is the home for active code running on the page, and should be the first place to look in order to understand the structure of what is happening. So for example if you are working on the home page of a site, then you can assume that PAGE.Modules.home will be there. Always start with PAGE in console, and just explore the Modules object first.
</div>

<div class="section" id="constructors">
<h2>Constructors</h2>
Constructors are functions that create Objects. They are Stateless, in that they themselves remain constant, generating Objects based on the parameters being passed in. All things considered, while Modules are required, Constructors are not. But the benefit of building out functionality as a Constructors instead of just as a part of a Module is that Constructors are easier to test. Because they are stateless, you can generate many objects from them, testing different combinations, and disposing of the objects when you are done. The same cannot be said for Modules.
</div>

<div class="section" id="functions">
<h2>Functions</h2>
Functions are stateless bits of code that do something for you without needing to generate objects. They might be used to modify objects, or numbers, or strings, or any other kind of quick work. Functions are the easiest thing to test, since there is an input and an output.
</div>

<div class="section" id="properties">
<h2>Properties</h2>
Properties are a repository for holding all of the global variables for a site. I generally put things like the User object. Since they are global, any Function, Constructor, or Module can read from them, or even write to them. They have no methods to themselves. They are mute that way.
</div>


<div class="section" id="thirdParty">
<h2>Third Party Libraries</h2>
Third Party libraries can be adapted into PAGE. jdog is pure javascript, but works best with jQuery. It can be modified for other DOM type libraries, but shouldn't have to. Third Party Libraries can be added in different ways, or waited for in different ways. Generally, external libraries add to the Global window object.

To load the script from PAGE, you would use PAGE.addExternalLib
if you have the script bundled, and you only want to reference it, then you can get to it either with:

PAGE.waitWindow
PAGE.batchWaitWindow

The benefit of batchWaitWindow is you can pass in many external library namespaces, and if you include a true flag, then the library will be added into PAGE.Lib. Later on you can simply call PAGE.wait("Lib.SomeLib", "Lib.SomeOtherLib", ref, function(...)

</div>

<div class="section" id="jQuery2">
<h2>jQuery is a special little library</h2>
I don't claim to love many javascript libraries, but I do love jQuery. It's a special case, so much so in fact that PAGE has it built in. Normally for jQuery you would need the following to ensure that jQuery is ready.

<code>
$(document).ready(<span class="Identifier">function</span>() {

<span class="Comment">  // lets do some good</span>

})
</code>

But I love jQuery and really don't want to have to type this:

<code>
$(document).ready(<span class="Identifier">function</span>() {


  PAGE.add(<span class="Constant">&quot;Modules.demo&quot;</span>, (<span class="Identifier">function</span>() {

<span class="Comment">    // lets do some good</span>

  }()))

})
</code>

So I created, out of necessity, the following:

<code>
PAGE.add$("Modules.demo", (function() {

	// lets do some good

}()))
</code>

The above code will first wait until jQuery is 'ready', ie, jQuery is loaded, and the DOM is ready, then it will add your module. Ideally you would only need this for Modules, since only modules interact directly with the DOM. Constructors and Functions only get instantiated after Modules, therefore it is fair to assume that jQuery is loaded.

</div>

<div class="section" id="extensions">
<h2>Extensions</h2>
Extensions are scripts that extend the PAGE library itself. Here is an example of one:

<code>
PAGE.extend(<span class="Identifier">function</span>(puppy, dog, log) {

  dog.GetTime = <span class="Identifier">function</span>() {
<span class="Comment">    // your code</span>
  }

})
</code>

As for convention, puppy is the instance, dog is the prototype, and log is any logging to console. It's easy to remember, that's why it's like that. If you must know, instance properties for PAGE act the same as prototype properties to PAGE. What's nice is to keep them seperated. In this way, prototype methods and properties can be hidden, and the output of typing PAGE is much cleaner.

</div>

<div class="section" id="custom">
<h2>Custom</h2>
It's perfectly common for javascript to have all sorts of interesting patterns. Javascript is one of the most expressive languages, and as such people try different ways of writing it.

Here is some interesting code to ponder:

<code>
<span class="Comment">// setup a base component</span>
PAGE.add(<span class="Constant">&quot;Components.Base&quot;</span>, <span class="Identifier">function</span>(obj) {

<span class="Comment">  // this utilizes what is called the module pattern</span>
<span class="Comment">  // an object is brought in and extended</span>

  obj.someProperty  = obj.someProperty  || <span class="Constant">123</span>
  obj.someProperty2 = obj.someProperty2 || { <span class="Statement">blah</span> : <span class="Constant">true</span> }

  obj.doSomething = <span class="Identifier">function</span>() {
<span class="Comment">    // your code</span>
  }

  <span class="Statement">return</span> obj

})

<span class="Comment">// create a component based on the Base component</span>
PAGE.add(<span class="Constant">&quot;Components.Input&quot;</span>, <span class="Identifier">function</span>(<span class="Comment">/* lots of stuff here */</span>) {

<span class="Comment">  // with this pattern we must ensure the Components.Base is fully loaded</span>
  <span class="Type">var</span> base = PAGE.exists(<span class="Constant">&quot;Components.Base&quot;</span>) || <span class="Identifier">function</span>(obj){ <span class="Statement">return</span> obj }

  <span class="Type">var</span> dog = base({

    <span class="Statement">someProperty</span> : <span class="Constant">514</span>
    , <span class="Statement">DoThis</span> : <span class="Identifier">function</span>() {
<span class="Comment">      // blah blah</span>
    }

  })

  <span class="Statement">return</span> dog

})

</code>


</div>

<div id="completeAPI">

AddExternalLib: function (path, globalVarName, callback) {
SwapLib: function (hash, base) {
add: function (path, obj) {
add$: function (path, thing) {
addExternalLib: function (path, globalVarName, callback) {
batchWait: function (/* str, str2, str3, obj, callback */) {
batchWaitRef: function (arr, ref, callback) {
batchWaitWindow: function (/* path, path, arr, path, add, callback */) {
done: function (func) { // method to add to finished callbackexists: function (path, base, alternate) {
extend: function extend(callback) {
getType: function (thing){
loadScript: function (/* pathToFile, allowCache */) {
loadStyle: function (/* pathToFile, allowCache */) {
log: function (thing) {
mapArguments: function (args) {
remove: function (path, base, swap) {
spawn: function (path, thing, base) {
stash: function (key) {
version: "2.0.2"wait: function (/* path, path2, path3, callback, refObj */) {
waitExists: function (path, base, func) {
waitList: ObjectwaitWindow: function (/* path, add, obj, callback */) {
</div>

</div>

</body>
<script src="page.js"></script>
<script src="page.constructors.NameOfConstructor.js"></script>
<script src="page.modules.nameOfModule.js"></script>
<script src="page.constructors.SpyCracker.js"></script>
<script src="page.modules.demo.js"></script>
</html>
