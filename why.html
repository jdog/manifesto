<!DOCTYPE html>
<html lang="en" class="Why">
<head>
<meta charset="UTF-8">
<title>A truly simple example</title>
<meta name="colorscheme" content="github">
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="sidePanel.css">
<script src="page.loader.js"></script>
</head>
<body>

	<div id="sidePanel">
		<span class="icon">â‰¡</span>
		<div class="guts">
			<div><a href="index.html">API</a></div>
			<div><a href="manifesto.html">Manifesto</a></div>
			<div><span>Why</span></div>
			<div><a href="examples.html">Examples</a></div>
			<div><a href="editor.html">Editor</a></div>
		</div>
	</div>

<div class="wrapper">
<h1>Why jDog?</h1>

<h4>History &amp; philosophy</h4>
<div class="jump">
<a href="#what">What is jDog?</a>
<a href="#intro">organizing code</a>
<a href="#intro">the single PAGE variable</a>
<a href="#earlyExample">early attempts</a>
<a href="#loadingProblem">the asynchronous loading problem</a>
</div>

<h4>Usage and Structure</h4>
<div class="jump">
<a href="#existential">PAGE is existential</a>
<a href="#order">loading order</a>
<a href="#structure">Structure</a>
<a href="#modules">Modules</a>
<a href="#constructors">Constructors</a>
<a href="#properties">Properties</a>
<a href="#functions">Functions</a>
<a href="#thirdParty">3rd party Libraries</a>
<a href="#jQuery2">jQuery</a>
<a href="#extensions">Extensions</a>
<a href="#custom">Custom</a>
</div>

<h4><a href="api.html">Complete API</a></h4>

<div class="section" id="what">
<h4>What is jDog (AKA PAGE)</h4>
jDog is a javascript library to organize and structure your scripts, giving easy access from within the web console and within your code to the global variable PAGE. It is also a pattern for developing code with good structure easily and consistently. And because it's been around awhile, it is also a growing body of scripts which interact with each other consistently and reliably allowing you to build out robust new code. It's a small library that will change the way you write javaScript.

<h4>Why do you need it?</h4>
jDog makes working with the browser console the most amazing experience ever. By stuffing everything into one explorable variable, <b>PAGE</b>, it dramatically simplifies the process of building and then debugging your project.
</div>

<div id="organize" class="section">
<h2>Organizing code</h2>
There are many ways to organize code for a website. From the early days of the web, with pure html, images, and maybe a few CGI scripts things were relatively easy. A few key folders, some files, and a some server settings. It's very easy to organize something that is simple which does very little. Things get more complicated as you introduce more functionality. As I write this in late 2014, javascript has become a driving force in the way developers think about and organize their web projects. There are many reasons for this trend, mostly boiling down to demand from consumers and product development requirements. The bottom line is for your code to make sense, it needs to be organized, and consistently so.

This is quite a challenge when you consider all of the possible ways of writing javaScript, and the many prevailing trends, existing libraries, and influential personalities who push this or that pattern or structure.
</div>

<div class="section" id="intro">
<h2>Why have a <i class="c">PAGE</i> variable</h2>
The <i class="c">PAGE</i> variable started out in the frustration of inheriting code from many different projects. When inheriting a project for the first time, certain important variables would be hidden inside the global window object, such as CurrentMemberId, or CampaignClass etc for example. Often javascript files would have functions and variables all meshed together, calling and modifying each other. 

For small projects this practice is understandable, but as the web evolved to expect ajax style interaction this practice broke down. This is especially true when trying to modify older code writing in this way. If you didn't know what to look for or have easy access to the complete code base, you can spend a lot of time just digging through the code to find what you need. Time wasted.

Viewing source (back in the day) would produce some serious spaghetti. It took a long time to understand the scope of adding new features. And often, features would never get removed since doing so could break something somewhere else in unexpected ways. In short it was a mess, and there was no standard way of organizing all of the mess.

For these reasons and many others I made the decision that for any new projects I would store things into a common variable called <i class="c">PAGE</i>. In that way, if I hadn't worked on the project in awhile I could type <i class="c">PAGE</i> in the console to peak at what was happening and get up to speed quickly.

<h3 id="earlyExample">At first the code looked something like this:</h3>
<pre>
  <span class="Statement">if</span> (<span class="Statement">typeof</span> PAGE === <span class="Constant">&quot;undefined&quot;</span>) {
    PAGE = { }
  }
  PAGE.SomeProperty = <span class="Constant">12314</span>
</pre>
But this technique got annoying since you always had to check for null. And if you had nested properties, it gets even worse.

<pre>
  <span class="Statement">if</span> (<span class="Statement">typeof</span> PAGE !== <span class="Constant">&quot;undefined&quot;</span>) {

    <span class="Statement">if</span> (PAGE.someThing &amp;&amp; PAGE.someThing.someProperty) {
<span class="Comment">      // ... do something</span>
    } <span class="Statement">else</span> {
<span class="Comment">      // ... looks like it's not defined</span>
    }

  }
</pre>
This constant need for retrieving and adding nested properties (PAGE.Something.SomethingElse) prompted me to come up with a standard way of accessing nested properties inside the <i class="c">PAGE</i> variable or window object.

This required PAGE to be it's own library, loading very early. Though this was itself annoying, it resolved a lot of common problems with asynchronous loading. After a couple rewrites, I eventually came up with this type of syntax:

<h3 class="mb0">Checking if a path exists</h3>
<pre class='vimCodeElement'>
<span class="Comment">// the old way of doing it</span>
<span class="Comment">// this is checking against the PAGE object</span>
<span class="Type">var</span> part1 = (PAGE &amp;&amp; PAGE.Something &amp;&amp; PAGE.Something.SomeOtherThing) ?
      PAGE.Something.SomeOtherThing.<span class="Statement">Part1</span> : <span class="Type">undefined</span>

<span class="Comment">// the way of dog</span>
<span class="Type">var</span> part1 = PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>)


<span class="Comment">// the old way of doing it</span>
<span class="Comment">// This checks against the window object</span>
<span class="Type">var</span> part1 = (window.Something &amp;&amp; window.Something.SomeOtherThing) ?
      window.Something.SomeOtherThing.<span class="Statement">Part1</span> : <span class="Type">undefined</span>

<span class="Comment">// the way of dog</span>
<span class="Type">var</span> part1 = PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>, window)

<span class="Comment">// the old way of doing it</span>
<span class="Comment">// This checks against the window object, return a default</span>
<span class="Type">var</span> part1 = (window.Something &amp;&amp; window.Something.SomeOtherThing) ?
      window.Something.SomeOtherThing.Part1 ? <span class="Constant">123</span> : <span class="Constant">123</span>

<span class="Comment">// the way of dog</span>
<span class="Type">var</span> part1 = PAGE.exists(<span class="Constant">&quot;Something.SomeOtherThing.Part1&quot;</span>, window, <span class="Constant">123</span>)
</pre>

<div class="expand">Source code for checking Existence</div>
<div class="expanse">
As you can see the essence of exists is pretty simple. First, split out the path by periods. The inner <i class="c">obj</i> variable gets redefined on each pass through the while loop. If it reaches an undefined or null it stops prematurely, otherwise it returns the property requested. Finally, there is an alternative variable which will return optionally if either the thing is undefined or the value is null.
<pre>
<span class="Type">var</span> exists = <span class="Identifier">function</span> (path, base, alternate) {
  <span class="Statement">if</span> (<span class="Statement">typeof</span> path === <span class="Constant">&quot;undefined&quot;</span> || <span class="Statement">typeof</span> path === <span class="Constant">&quot;object&quot;</span>) <span class="Statement">return</span>
  <span class="Type">var</span> arr = path.split(<span class="Constant">&quot;.&quot;</span>)
    , x = <span class="Constant">0</span>
    , obj = base || PAGE

  <span class="Statement">if</span> (arr.length &lt; <span class="Constant">1</span>) <span class="Statement">return</span> alternate

  <span class="Statement">while</span> (x &lt; arr.length) {
    obj = obj[arr[x]]
    <span class="Statement">if</span> (obj === <span class="Type">undefined</span> || obj === <span class="Type">null</span>) <span class="Statement">return</span> alternate
    x++
  }
  <span class="Statement">if</span> (<span class="Statement">typeof</span> obj !== <span class="Constant">&quot;undefined&quot;</span>)
    <span class="Statement">return</span> obj
  <span class="Statement">else</span>
    <span class="Statement">return</span> alternate
}
</pre>
</div>
<h3 class="mb0">Interesting tricks of existential awareness!</h3>
<pre class='vimCodeElement'>
<span class="Comment">// here are some cool things you can do with exists</span>

<span class="Comment">// somewhere in my project I have defined a function</span>

MyProject.someAmazingModule.reload = <span class="Identifier">function</span>(delay) { <span class="Comment">/* ......... */</span> }

<span class="Comment">// and I am not entirely sure it has loaded yet, but I don't want to wait for it</span>

PAGE.exists(<span class="Constant">&quot;someAmazingModule.reload&quot;</span>, MyProject, <span class="Identifier">function</span>(){})( <span class="Constant">500</span> )

<span class="Comment">// what did that just do?</span>
<span class="Comment">//</span>
<span class="Comment">// 1. Look inside window.MyProject for someAmazingModule</span>
<span class="Comment">// 2. look inside someAmazingModule for reload</span>
<span class="Comment">// 3. return it and call it with 500 as the parameter</span>
<span class="Comment">// 4. if it's not there, return and call anonymous function</span>
</pre>
</div>

<div id="loadingProblem" class="section">
<h3>The asynchronous loading problem with javascript</h3>
A good practice to employ while coding any complex project is separating concerns. Break down the functionality from the data, break apart the functionality by what it does. Break apart code that reads or writes to the database, writes cookies or localStorage. Headers, footers, tracking code etc etc. In javascript, as in other languages, this is done by saving different concerns as their own file, with a unique name for the file that corresponds to the unique name of the function or object or extension.

<u>So what's the problem?</u>

JavaScript differs from other languages however in that it is running in a browser. The browser is designed to work over a network, that could be fast or slow, where items on the page will progressively paint until everything is finished loading. If there are different files being loaded by the browser, some will load before others. This is what is known as asynchronous loading. Those who write code in compiled languages rarely have to face this problem or implement ways to resolve it. This is a huge source of grief for many developers new to javascript as they expect all things to be available now. 

To add even more complexity, production code often differs from development code. Keep in mind that while writing and debugging your code it wise to keep files separate, have lots of comments, but for production it is best to bundle all the necessary files together, remove all redundant information, and shrink it down and compress it. 

Compiled language namespace solutions use a <i class="c">Using</i> statement towards the top of the file. Upon compilation, the required libraries are then hoisted into scope to be accessed by the code that needs them. In javascript it is not that simple because everything is loading asynchronously.

A working solution, though a bad one, would wait for all required libraries to be loaded before running the code. The problem with this is that some files might not be needed till long after the page finishes loading. Imagine a login popup which only needs to be loaded after you click the login button. A better solution is to break down the page into areas you want loaded first, or later.

A better solution would split the work of a <i>Component</i> into the parts that can run without external <i>Components</i> and the parts that require external components. In this way the processor would work on the stuff that it can now, then get to the stuff that is still being loaded later. Thanks to the power of javascript you can do this very thing, as the scope in the closure allows full access to variables long after they are first loaded.

One of the advantages of jDog over Module loading scripts is the emphasis on Constructors and other non Module type objects. Later on I will expound upon the differences, but for this topic, Constructors are Functions that output Objects which can have Methods and properties. If you understand Object Oriented Architecture, Constructors can be thought of as a Class. In JavaScript, Constructors have even more functionality.
</div>

<div id="howPageWorks" class="section">
<h3>How jDog tackles the asynchronous problem</h3>
If jDog does anything well, it is tackling the asynchronous loading problem with web based javascript. The primary technique is quite simple. <a href="/api.html#wait">PAGE.wait</a>

</div>

<div class="section" id="order">
<h2>The Order of things</h2>
When working with asynchronous code, you never can be absolutely sure of the load order. For PAGE (jdog) to work properly, it should be added before any other PAGE items. Also, though it's not dependant on jQuery, it certainly interacts with jQuery faster if jQuery is loaded before PAGE. Normally I load jQuery through google's hosted library. This speeds up the page loading since the source is coming from a different domain.

<h3>Ideal Order</h3>
<pre>
	1) PAGE.loader.js          // add this to the PAGE bundle, or directly on HTML
	2) PAGE.base.js            // add this to the PAGE bundle
	3) jQuery                  // add this to the page bundle
	4) (any page extensions)   // add this to the PAGE bundle
	5) (any page constructors or functions or properties)
	6) (any page modules)
</pre>

</div>

<div class="section" id="structure">
<h2>Structure of your PAGE</h2>

To a large degree the structure of your page is up to you. <i>jdog</i> is not a framework like angular or similar libraries that requires a rigid structure or pattern to develop around. jdog is framework independent. This means you have more freedom to adapt other javascript libraries since there are no dependency conflicts to contend with. It really is up to you to structure your code the best way you can. jdog is a library management tool.

Javascript is a very expressive language which allows for many different types of patterns. In my practice the following ways of grouping code have been beneficial.

<dl>
<dt>Modules</dt>
<dd>These are the instantiated objects in the page</dd>
<dt>Constructors</dt>
<dd>These are functions that Construct Objects (either Modules, or the sub parts to Modules)</dd>
<dt>Functions</dt>
<dd>Stateless scripts that affect Modules or their parts</dd>
<dt>Properties</dt>
<dd>Global variables which allow easy communication from backend</dd>
<dt>Extensions</dt>
<dd>Scripts which extend the functionality of the PAGE library</dd>
<dt>Module Extenders</dt>
<dd>Bits of code that expand the functionality of modules</dd>
<dt>External Libraries</dt>
<dd>Any of a million javascript libraries</dd>
</dl>


</div>

<div class="section" id="modules">
<h2>What do I mean by Module?</h2>
A Module is an Object that exists on your page with public properties and methods. Modules are stateful Singletons. Whereas a Function takes parameters and runs some script, Modules are the thing itself. They rarely if ever get removed, instead their properties change states. This is the home for active code running on the page, and should be the first place to look in order to understand the structure of what is happening. So for example if you are working on the home page of a site, then you can assume that PAGE.Modules.home will be there. Always start with PAGE in console, and just explore the Modules object first.
</div>

<div class="section" id="constructors">
<h2>Constructors</h2>
Constructors are functions that create Objects. They are Stateless, in that they themselves remain constant, generating Objects based on the parameters being passed in. All things considered, while Modules are required, Constructors are not. But the benefit of building out functionality as a Constructors instead of just as a part of a Module is that Constructors are easier to test. Because they are stateless, you can generate many objects from them, testing different combinations, and disposing of the objects when you are done. The same cannot be said for Modules.
</div>

<div class="section" id="functions">
<h2>Functions</h2>
Functions are stateless bits of code that do something for you without needing to generate objects. They might be used to modify objects, or numbers, or strings, or any other kind of quick work. Functions are the easiest thing to test, since there is an input and an output.
</div>

<div class="section" id="properties">
<h2>Properties</h2>
Properties are a repository for holding all of the global variables for a site. I generally put things like the User object. Since they are global, any Function, Constructor, or Module can read from them, or even write to them. They have no methods to themselves. They are mute that way.
</div>

<div class="section" id="thirdParty">
<h2>Third Party Libraries</h2>
Third Party libraries can be added in different ways. Generally, external libraries add to the window object, and as such can be 'waited' for like everything else.

To load the script from PAGE, you would use <a href="api.html#loadScript">PAGE.load</a>
<pre class='vimCodeElement'>
PAGE.load(<span class="Constant">&quot;/Scripts/folder/ExternalSpinnerExample.js&quot;</span>)
</pre>
if you have the script bundled, (as you should), you only need to reference it when it's loaded in the normal way, with the exception that you include the 'window' object as the root.
<pre class='vimCodeElement'>
PAGE.wait(<span class="Constant">&quot;window.ExternalSpinnerExample&quot;</span>, <span class="Identifier">function</span>(ExternalSpinnerExample) {
  ExternalSpinnerExample()
})
</pre>
or
<pre class='vimCodeElement'>
PAGE.wait(
  <span class="Constant">&quot;window.ExternalSpinnerExample&quot;</span>
  , ref
  , <span class="Identifier">function</span>(ref) {
  ref.ExternalSpinnerExample
})
</pre>
</div>

<div class="section" id="jQuery2">
<h2>jQuery is a special little library</h2>
I don't claim to love many javascript libraries, but I do love jQuery. It's a special case, so much so in fact that PAGE built in integration for it. Normally for jQuery you would need the following to ensure that jQuery and the DOM are ready to play together.
<pre>
$(document).ready(<span class="Identifier">function</span>() {
<span class="Comment">  // lets do some good</span>
})
</pre>
But I love and use jQuery often, and really don't want to have to type this every time I want to use jQuery with jDog.
<pre>
$(document).ready(<span class="Identifier">function</span>() {
  PAGE.add(<span class="Constant">&quot;Modules.demo&quot;</span>, (<span class="Identifier">function</span>() {
<span class="Comment">    // lets do some good</span>
  }()))
})
</pre>
And though new HTML5 tricks bring fuel to the argument that it is no longer required for DOM manipulation, there are so many wonderful libraries using jQuery, why not make it easy? So I created both <a href="api.html#add$">add$</a> and <a href="api.html#addWait$">addWait$</a>:
<pre class='vimCodeElement'>
<span class="Comment">// for simple adding</span>
PAGE.add$(<span class="Constant">&quot;Modules.home&quot;</span>, (<span class="Identifier">function</span>() {

  <span class="Type">var</span> exports = {
    $btn : $(<span class="Constant">&quot;button[name='Submit']&quot;</span>)
    , $name : $(<span class="Constant">&quot;input[name='Name']&quot;</span>)
  }

  exports.$btn.click(<span class="Identifier">function</span>() {
    alert(<span class="Constant">&quot;clicked the button : value = &quot;</span> + exports.$btn.val())
  })

  <span class="Statement">return</span> exports

}()))


<span class="Comment">// for simple waiting then adding</span>
PAGE.addWait$(
  <span class="Constant">&quot;Modules.home&quot;</span>
  , [
    <span class="Constant">&quot;window.jQuery.fn.select2&quot;</span>
    , <span class="Constant">&quot;Modules.dataService.read&quot;</span>
  ]
  , (<span class="Identifier">function</span>(ref) {

  <span class="Type">var</span> exports = {
    $btn : $(<span class="Constant">&quot;button[name='Submit']&quot;</span>)
    , $name : $(<span class="Constant">&quot;input[name='Name']&quot;</span>)
  }

  exports.$btn.click(<span class="Identifier">function</span>() {
    alert(<span class="Constant">&quot;clicked the button : value = &quot;</span> + exports.$btn.val())
  })

  <span class="Statement">return</span> exports

}()))
</pre>
The above code will first wait until jQuery is 'ready', ie, jQuery is loaded, and the DOM is ready, then it will add your module. Ideally you would only need this for Modules, since only modules interact directly with the DOM. Constructors and Functions only get instantiated after Modules, therefore it is fair to assume that jQuery is loaded.
</div>

<div class="section" id="extensions">
<h2>Extensions</h2>
Extensions are scripts that extend the PAGE library itself. Here is an example of one:

<pre>
PAGE.extend(<span class="Identifier">function</span>(puppy, dog, log) {

  dog.GetTime = <span class="Identifier">function</span>() {
<span class="Comment">    // your code</span>
  }

})
</pre>

As for convention, puppy is the instance, dog is the prototype, and log is any logging to console. It's easy to remember, that's why it's like that. If you must know, instance properties for PAGE act the same as prototype properties to PAGE. What's nice is to keep them separated. In this way, prototype methods and properties can be hidden, and the output of typing PAGE is much cleaner.

</div>

<div class="section" id="custom">
<h2>Custom</h2>
It's perfectly common for javascript to have all sorts of interesting patterns. Javascript is one of the most expressive languages, and as such people try different ways of writing it.

Here is some interesting code to ponder:

<pre>
<span class="Comment">// setup a base component</span>
PAGE.add(<span class="Constant">&quot;Components.Base&quot;</span>, <span class="Identifier">function</span>(obj) {

<span class="Comment">  // this utilizes what is called the module pattern</span>
<span class="Comment">  // an object is brought in and extended</span>

  obj.someProperty  = obj.someProperty  || <span class="Constant">123</span>
  obj.someProperty2 = obj.someProperty2 || { <span class="Statement">blah</span> : <span class="Constant">true</span> }

  obj.doSomething = <span class="Identifier">function</span>() {
<span class="Comment">    // your code</span>
  }

  <span class="Statement">return</span> obj

})

<span class="Comment">// create a component based on the Base component</span>
PAGE.add(<span class="Constant">&quot;Components.Input&quot;</span>, <span class="Identifier">function</span>(<span class="Comment">/* lots of stuff here */</span>) {

<span class="Comment">  // with this pattern we must ensure the Components.Base is fully loaded</span>
  <span class="Type">var</span> base = PAGE.exists(<span class="Constant">&quot;Components.Base&quot;</span>) || <span class="Identifier">function</span>(obj){ <span class="Statement">return</span> obj }

  <span class="Type">var</span> dog = base({

    <span class="Statement">someProperty</span> : <span class="Constant">514</span>
    , <span class="Statement">DoThis</span> : <span class="Identifier">function</span>() {
<span class="Comment">      // blah blah</span>
    }

  })

  <span class="Statement">return</span> dog

})

</pre>


</div>

</div>
</body>
<script src="page.Modules.navigation.js"></script>
</html>
